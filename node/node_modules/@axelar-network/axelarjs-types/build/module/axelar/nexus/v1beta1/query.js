/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Duration } from "../../../google/protobuf/duration";
import { CrossChainTransfer, FeeInfo, GeneralMessage, transferStateFromJSON, transferStateToJSON, } from "../exported/v1beta1/types";
import { ChainState } from "./types";
export const protobufPackage = "axelar.nexus.v1beta1";
export var ChainStatus;
(function (ChainStatus) {
    ChainStatus[ChainStatus["CHAIN_STATUS_UNSPECIFIED"] = 0] = "CHAIN_STATUS_UNSPECIFIED";
    ChainStatus[ChainStatus["CHAIN_STATUS_ACTIVATED"] = 1] = "CHAIN_STATUS_ACTIVATED";
    ChainStatus[ChainStatus["CHAIN_STATUS_DEACTIVATED"] = 2] = "CHAIN_STATUS_DEACTIVATED";
    ChainStatus[ChainStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ChainStatus || (ChainStatus = {}));
export function chainStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "CHAIN_STATUS_UNSPECIFIED":
            return ChainStatus.CHAIN_STATUS_UNSPECIFIED;
        case 1:
        case "CHAIN_STATUS_ACTIVATED":
            return ChainStatus.CHAIN_STATUS_ACTIVATED;
        case 2:
        case "CHAIN_STATUS_DEACTIVATED":
            return ChainStatus.CHAIN_STATUS_DEACTIVATED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ChainStatus.UNRECOGNIZED;
    }
}
export function chainStatusToJSON(object) {
    switch (object) {
        case ChainStatus.CHAIN_STATUS_UNSPECIFIED:
            return "CHAIN_STATUS_UNSPECIFIED";
        case ChainStatus.CHAIN_STATUS_ACTIVATED:
            return "CHAIN_STATUS_ACTIVATED";
        case ChainStatus.CHAIN_STATUS_DEACTIVATED:
            return "CHAIN_STATUS_DEACTIVATED";
        case ChainStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseChainMaintainersRequest() {
    return { chain: "" };
}
export const ChainMaintainersRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainMaintainersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chain: isSet(object.chain) ? String(object.chain) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        return obj;
    },
    create(base) {
        return ChainMaintainersRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainMaintainersRequest();
        message.chain = object.chain ?? "";
        return message;
    },
};
function createBaseChainMaintainersResponse() {
    return { maintainers: [] };
}
export const ChainMaintainersResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.maintainers) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainMaintainersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.maintainers.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            maintainers: Array.isArray(object?.maintainers) ? object.maintainers.map((e) => bytesFromBase64(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.maintainers) {
            obj.maintainers = message.maintainers.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.maintainers = [];
        }
        return obj;
    },
    create(base) {
        return ChainMaintainersResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainMaintainersResponse();
        message.maintainers = object.maintainers?.map((e) => e) || [];
        return message;
    },
};
function createBaseLatestDepositAddressRequest() {
    return { recipientAddr: "", recipientChain: "", depositChain: "" };
}
export const LatestDepositAddressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.recipientAddr !== "") {
            writer.uint32(10).string(message.recipientAddr);
        }
        if (message.recipientChain !== "") {
            writer.uint32(18).string(message.recipientChain);
        }
        if (message.depositChain !== "") {
            writer.uint32(26).string(message.depositChain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLatestDepositAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.recipientAddr = reader.string();
                    break;
                case 2:
                    message.recipientChain = reader.string();
                    break;
                case 3:
                    message.depositChain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            recipientAddr: isSet(object.recipientAddr) ? String(object.recipientAddr) : "",
            recipientChain: isSet(object.recipientChain) ? String(object.recipientChain) : "",
            depositChain: isSet(object.depositChain) ? String(object.depositChain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.recipientAddr !== undefined && (obj.recipientAddr = message.recipientAddr);
        message.recipientChain !== undefined && (obj.recipientChain = message.recipientChain);
        message.depositChain !== undefined && (obj.depositChain = message.depositChain);
        return obj;
    },
    create(base) {
        return LatestDepositAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLatestDepositAddressRequest();
        message.recipientAddr = object.recipientAddr ?? "";
        message.recipientChain = object.recipientChain ?? "";
        message.depositChain = object.depositChain ?? "";
        return message;
    },
};
function createBaseLatestDepositAddressResponse() {
    return { depositAddr: "" };
}
export const LatestDepositAddressResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.depositAddr !== "") {
            writer.uint32(10).string(message.depositAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLatestDepositAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.depositAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { depositAddr: isSet(object.depositAddr) ? String(object.depositAddr) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.depositAddr !== undefined && (obj.depositAddr = message.depositAddr);
        return obj;
    },
    create(base) {
        return LatestDepositAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLatestDepositAddressResponse();
        message.depositAddr = object.depositAddr ?? "";
        return message;
    },
};
function createBaseTransfersForChainRequest() {
    return { chain: "", state: 0, pagination: undefined };
}
export const TransfersForChainRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.state !== 0) {
            writer.uint32(16).int32(message.state);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransfersForChainRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.state = reader.int32();
                    break;
                case 3:
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            chain: isSet(object.chain) ? String(object.chain) : "",
            state: isSet(object.state) ? transferStateFromJSON(object.state) : 0,
            pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        message.state !== undefined && (obj.state = transferStateToJSON(message.state));
        message.pagination !== undefined &&
            (obj.pagination = message.pagination ? PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    create(base) {
        return TransfersForChainRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransfersForChainRequest();
        message.chain = object.chain ?? "";
        message.state = object.state ?? 0;
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseTransfersForChainResponse() {
    return { transfers: [], pagination: undefined };
}
export const TransfersForChainResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.transfers) {
            CrossChainTransfer.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransfersForChainResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transfers.push(CrossChainTransfer.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfers: Array.isArray(object?.transfers)
                ? object.transfers.map((e) => CrossChainTransfer.fromJSON(e))
                : [],
            pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfers) {
            obj.transfers = message.transfers.map((e) => e ? CrossChainTransfer.toJSON(e) : undefined);
        }
        else {
            obj.transfers = [];
        }
        message.pagination !== undefined &&
            (obj.pagination = message.pagination ? PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    create(base) {
        return TransfersForChainResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransfersForChainResponse();
        message.transfers = object.transfers?.map((e) => CrossChainTransfer.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseFeeInfoRequest() {
    return { chain: "", asset: "" };
}
export const FeeInfoRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.asset !== "") {
            writer.uint32(18).string(message.asset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFeeInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.asset = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            chain: isSet(object.chain) ? String(object.chain) : "",
            asset: isSet(object.asset) ? String(object.asset) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        message.asset !== undefined && (obj.asset = message.asset);
        return obj;
    },
    create(base) {
        return FeeInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFeeInfoRequest();
        message.chain = object.chain ?? "";
        message.asset = object.asset ?? "";
        return message;
    },
};
function createBaseFeeInfoResponse() {
    return { feeInfo: undefined };
}
export const FeeInfoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.feeInfo !== undefined) {
            FeeInfo.encode(message.feeInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFeeInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.feeInfo = FeeInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { feeInfo: isSet(object.feeInfo) ? FeeInfo.fromJSON(object.feeInfo) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.feeInfo !== undefined && (obj.feeInfo = message.feeInfo ? FeeInfo.toJSON(message.feeInfo) : undefined);
        return obj;
    },
    create(base) {
        return FeeInfoResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFeeInfoResponse();
        message.feeInfo = (object.feeInfo !== undefined && object.feeInfo !== null)
            ? FeeInfo.fromPartial(object.feeInfo)
            : undefined;
        return message;
    },
};
function createBaseTransferFeeRequest() {
    return { sourceChain: "", destinationChain: "", amount: "" };
}
export const TransferFeeRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sourceChain !== "") {
            writer.uint32(10).string(message.sourceChain);
        }
        if (message.destinationChain !== "") {
            writer.uint32(18).string(message.destinationChain);
        }
        if (message.amount !== "") {
            writer.uint32(26).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferFeeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sourceChain = reader.string();
                    break;
                case 2:
                    message.destinationChain = reader.string();
                    break;
                case 3:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sourceChain: isSet(object.sourceChain) ? String(object.sourceChain) : "",
            destinationChain: isSet(object.destinationChain) ? String(object.destinationChain) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sourceChain !== undefined && (obj.sourceChain = message.sourceChain);
        message.destinationChain !== undefined && (obj.destinationChain = message.destinationChain);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    create(base) {
        return TransferFeeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferFeeRequest();
        message.sourceChain = object.sourceChain ?? "";
        message.destinationChain = object.destinationChain ?? "";
        message.amount = object.amount ?? "";
        return message;
    },
};
function createBaseTransferFeeResponse() {
    return { fee: undefined };
}
export const TransferFeeResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fee !== undefined) {
            Coin.encode(message.fee, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferFeeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fee = Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { fee: isSet(object.fee) ? Coin.fromJSON(object.fee) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.fee !== undefined && (obj.fee = message.fee ? Coin.toJSON(message.fee) : undefined);
        return obj;
    },
    create(base) {
        return TransferFeeResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferFeeResponse();
        message.fee = (object.fee !== undefined && object.fee !== null) ? Coin.fromPartial(object.fee) : undefined;
        return message;
    },
};
function createBaseChainsRequest() {
    return { status: 0 };
}
export const ChainsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.status !== 0) {
            writer.uint32(8).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { status: isSet(object.status) ? chainStatusFromJSON(object.status) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.status !== undefined && (obj.status = chainStatusToJSON(message.status));
        return obj;
    },
    create(base) {
        return ChainsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainsRequest();
        message.status = object.status ?? 0;
        return message;
    },
};
function createBaseChainsResponse() {
    return { chains: [] };
}
export const ChainsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.chains) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chains.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chains: Array.isArray(object?.chains) ? object.chains.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.chains) {
            obj.chains = message.chains.map((e) => e);
        }
        else {
            obj.chains = [];
        }
        return obj;
    },
    create(base) {
        return ChainsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainsResponse();
        message.chains = object.chains?.map((e) => e) || [];
        return message;
    },
};
function createBaseAssetsRequest() {
    return { chain: "" };
}
export const AssetsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAssetsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chain: isSet(object.chain) ? String(object.chain) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        return obj;
    },
    create(base) {
        return AssetsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAssetsRequest();
        message.chain = object.chain ?? "";
        return message;
    },
};
function createBaseAssetsResponse() {
    return { assets: [] };
}
export const AssetsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.assets) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAssetsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.assets.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { assets: Array.isArray(object?.assets) ? object.assets.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.assets) {
            obj.assets = message.assets.map((e) => e);
        }
        else {
            obj.assets = [];
        }
        return obj;
    },
    create(base) {
        return AssetsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAssetsResponse();
        message.assets = object.assets?.map((e) => e) || [];
        return message;
    },
};
function createBaseChainStateRequest() {
    return { chain: "" };
}
export const ChainStateRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainStateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chain: isSet(object.chain) ? String(object.chain) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        return obj;
    },
    create(base) {
        return ChainStateRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainStateRequest();
        message.chain = object.chain ?? "";
        return message;
    },
};
function createBaseChainStateResponse() {
    return { state: undefined };
}
export const ChainStateResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.state !== undefined) {
            ChainState.encode(message.state, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainStateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.state = ChainState.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { state: isSet(object.state) ? ChainState.fromJSON(object.state) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.state !== undefined && (obj.state = message.state ? ChainState.toJSON(message.state) : undefined);
        return obj;
    },
    create(base) {
        return ChainStateResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainStateResponse();
        message.state = (object.state !== undefined && object.state !== null)
            ? ChainState.fromPartial(object.state)
            : undefined;
        return message;
    },
};
function createBaseChainsByAssetRequest() {
    return { asset: "" };
}
export const ChainsByAssetRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.asset !== "") {
            writer.uint32(10).string(message.asset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainsByAssetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.asset = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { asset: isSet(object.asset) ? String(object.asset) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.asset !== undefined && (obj.asset = message.asset);
        return obj;
    },
    create(base) {
        return ChainsByAssetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainsByAssetRequest();
        message.asset = object.asset ?? "";
        return message;
    },
};
function createBaseChainsByAssetResponse() {
    return { chains: [] };
}
export const ChainsByAssetResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.chains) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainsByAssetResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chains.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chains: Array.isArray(object?.chains) ? object.chains.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.chains) {
            obj.chains = message.chains.map((e) => e);
        }
        else {
            obj.chains = [];
        }
        return obj;
    },
    create(base) {
        return ChainsByAssetResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainsByAssetResponse();
        message.chains = object.chains?.map((e) => e) || [];
        return message;
    },
};
function createBaseRecipientAddressRequest() {
    return { depositAddr: "", depositChain: "" };
}
export const RecipientAddressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.depositAddr !== "") {
            writer.uint32(10).string(message.depositAddr);
        }
        if (message.depositChain !== "") {
            writer.uint32(18).string(message.depositChain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecipientAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.depositAddr = reader.string();
                    break;
                case 2:
                    message.depositChain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            depositAddr: isSet(object.depositAddr) ? String(object.depositAddr) : "",
            depositChain: isSet(object.depositChain) ? String(object.depositChain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.depositAddr !== undefined && (obj.depositAddr = message.depositAddr);
        message.depositChain !== undefined && (obj.depositChain = message.depositChain);
        return obj;
    },
    create(base) {
        return RecipientAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecipientAddressRequest();
        message.depositAddr = object.depositAddr ?? "";
        message.depositChain = object.depositChain ?? "";
        return message;
    },
};
function createBaseRecipientAddressResponse() {
    return { recipientAddr: "", recipientChain: "" };
}
export const RecipientAddressResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.recipientAddr !== "") {
            writer.uint32(10).string(message.recipientAddr);
        }
        if (message.recipientChain !== "") {
            writer.uint32(18).string(message.recipientChain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecipientAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.recipientAddr = reader.string();
                    break;
                case 2:
                    message.recipientChain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            recipientAddr: isSet(object.recipientAddr) ? String(object.recipientAddr) : "",
            recipientChain: isSet(object.recipientChain) ? String(object.recipientChain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.recipientAddr !== undefined && (obj.recipientAddr = message.recipientAddr);
        message.recipientChain !== undefined && (obj.recipientChain = message.recipientChain);
        return obj;
    },
    create(base) {
        return RecipientAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecipientAddressResponse();
        message.recipientAddr = object.recipientAddr ?? "";
        message.recipientChain = object.recipientChain ?? "";
        return message;
    },
};
function createBaseTransferRateLimitRequest() {
    return { chain: "", asset: "" };
}
export const TransferRateLimitRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.asset !== "") {
            writer.uint32(18).string(message.asset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferRateLimitRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.asset = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            chain: isSet(object.chain) ? String(object.chain) : "",
            asset: isSet(object.asset) ? String(object.asset) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        message.asset !== undefined && (obj.asset = message.asset);
        return obj;
    },
    create(base) {
        return TransferRateLimitRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferRateLimitRequest();
        message.chain = object.chain ?? "";
        message.asset = object.asset ?? "";
        return message;
    },
};
function createBaseTransferRateLimitResponse() {
    return { transferRateLimit: undefined };
}
export const TransferRateLimitResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.transferRateLimit !== undefined) {
            TransferRateLimit.encode(message.transferRateLimit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferRateLimitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transferRateLimit = TransferRateLimit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            transferRateLimit: isSet(object.transferRateLimit)
                ? TransferRateLimit.fromJSON(object.transferRateLimit)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.transferRateLimit !== undefined && (obj.transferRateLimit = message.transferRateLimit
            ? TransferRateLimit.toJSON(message.transferRateLimit)
            : undefined);
        return obj;
    },
    create(base) {
        return TransferRateLimitResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferRateLimitResponse();
        message.transferRateLimit = (object.transferRateLimit !== undefined && object.transferRateLimit !== null)
            ? TransferRateLimit.fromPartial(object.transferRateLimit)
            : undefined;
        return message;
    },
};
function createBaseTransferRateLimit() {
    return {
        limit: new Uint8Array(),
        window: undefined,
        incoming: new Uint8Array(),
        outgoing: new Uint8Array(),
        timeLeft: undefined,
    };
}
export const TransferRateLimit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.limit.length !== 0) {
            writer.uint32(10).bytes(message.limit);
        }
        if (message.window !== undefined) {
            Duration.encode(message.window, writer.uint32(18).fork()).ldelim();
        }
        if (message.incoming.length !== 0) {
            writer.uint32(26).bytes(message.incoming);
        }
        if (message.outgoing.length !== 0) {
            writer.uint32(34).bytes(message.outgoing);
        }
        if (message.timeLeft !== undefined) {
            Duration.encode(message.timeLeft, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferRateLimit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.limit = reader.bytes();
                    break;
                case 2:
                    message.window = Duration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.incoming = reader.bytes();
                    break;
                case 4:
                    message.outgoing = reader.bytes();
                    break;
                case 5:
                    message.timeLeft = Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            limit: isSet(object.limit) ? bytesFromBase64(object.limit) : new Uint8Array(),
            window: isSet(object.window) ? Duration.fromJSON(object.window) : undefined,
            incoming: isSet(object.incoming) ? bytesFromBase64(object.incoming) : new Uint8Array(),
            outgoing: isSet(object.outgoing) ? bytesFromBase64(object.outgoing) : new Uint8Array(),
            timeLeft: isSet(object.timeLeft) ? Duration.fromJSON(object.timeLeft) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.limit !== undefined &&
            (obj.limit = base64FromBytes(message.limit !== undefined ? message.limit : new Uint8Array()));
        message.window !== undefined && (obj.window = message.window ? Duration.toJSON(message.window) : undefined);
        message.incoming !== undefined &&
            (obj.incoming = base64FromBytes(message.incoming !== undefined ? message.incoming : new Uint8Array()));
        message.outgoing !== undefined &&
            (obj.outgoing = base64FromBytes(message.outgoing !== undefined ? message.outgoing : new Uint8Array()));
        message.timeLeft !== undefined && (obj.timeLeft = message.timeLeft ? Duration.toJSON(message.timeLeft) : undefined);
        return obj;
    },
    create(base) {
        return TransferRateLimit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferRateLimit();
        message.limit = object.limit ?? new Uint8Array();
        message.window = (object.window !== undefined && object.window !== null)
            ? Duration.fromPartial(object.window)
            : undefined;
        message.incoming = object.incoming ?? new Uint8Array();
        message.outgoing = object.outgoing ?? new Uint8Array();
        message.timeLeft = (object.timeLeft !== undefined && object.timeLeft !== null)
            ? Duration.fromPartial(object.timeLeft)
            : undefined;
        return message;
    },
};
function createBaseMessageRequest() {
    return { id: "" };
}
export const MessageRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    create(base) {
        return MessageRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMessageRequest();
        message.id = object.id ?? "";
        return message;
    },
};
function createBaseMessageResponse() {
    return { message: undefined };
}
export const MessageResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.message !== undefined) {
            GeneralMessage.encode(message.message, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = GeneralMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { message: isSet(object.message) ? GeneralMessage.fromJSON(object.message) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.message !== undefined &&
            (obj.message = message.message ? GeneralMessage.toJSON(message.message) : undefined);
        return obj;
    },
    create(base) {
        return MessageResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMessageResponse();
        message.message = (object.message !== undefined && object.message !== null)
            ? GeneralMessage.fromPartial(object.message)
            : undefined;
        return message;
    },
};
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis.Buffer) {
        return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis.btoa(bin.join(""));
    }
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
