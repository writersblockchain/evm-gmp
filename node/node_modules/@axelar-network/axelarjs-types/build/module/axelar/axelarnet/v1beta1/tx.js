/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Duration } from "../../../google/protobuf/duration";
import { Asset, Chain } from "../../nexus/exported/v1beta1/types";
import { Fee } from "./types";
export const protobufPackage = "axelar.axelarnet.v1beta1";
function createBaseLinkRequest() {
    return { sender: new Uint8Array(), recipientAddr: "", recipientChain: "", asset: "" };
}
export const LinkRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.recipientAddr !== "") {
            writer.uint32(18).string(message.recipientAddr);
        }
        if (message.recipientChain !== "") {
            writer.uint32(26).string(message.recipientChain);
        }
        if (message.asset !== "") {
            writer.uint32(34).string(message.asset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLinkRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.recipientAddr = reader.string();
                    break;
                case 3:
                    message.recipientChain = reader.string();
                    break;
                case 4:
                    message.asset = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            recipientAddr: isSet(object.recipientAddr) ? String(object.recipientAddr) : "",
            recipientChain: isSet(object.recipientChain) ? String(object.recipientChain) : "",
            asset: isSet(object.asset) ? String(object.asset) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.recipientAddr !== undefined && (obj.recipientAddr = message.recipientAddr);
        message.recipientChain !== undefined && (obj.recipientChain = message.recipientChain);
        message.asset !== undefined && (obj.asset = message.asset);
        return obj;
    },
    create(base) {
        return LinkRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLinkRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.recipientAddr = object.recipientAddr ?? "";
        message.recipientChain = object.recipientChain ?? "";
        message.asset = object.asset ?? "";
        return message;
    },
};
function createBaseLinkResponse() {
    return { depositAddr: "" };
}
export const LinkResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.depositAddr !== "") {
            writer.uint32(10).string(message.depositAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLinkResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.depositAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { depositAddr: isSet(object.depositAddr) ? String(object.depositAddr) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.depositAddr !== undefined && (obj.depositAddr = message.depositAddr);
        return obj;
    },
    create(base) {
        return LinkResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLinkResponse();
        message.depositAddr = object.depositAddr ?? "";
        return message;
    },
};
function createBaseConfirmDepositRequest() {
    return { sender: new Uint8Array(), depositAddress: new Uint8Array(), denom: "" };
}
export const ConfirmDepositRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.depositAddress.length !== 0) {
            writer.uint32(34).bytes(message.depositAddress);
        }
        if (message.denom !== "") {
            writer.uint32(42).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConfirmDepositRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 4:
                    message.depositAddress = reader.bytes();
                    break;
                case 5:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            depositAddress: isSet(object.depositAddress) ? bytesFromBase64(object.depositAddress) : new Uint8Array(),
            denom: isSet(object.denom) ? String(object.denom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.depositAddress !== undefined &&
            (obj.depositAddress = base64FromBytes(message.depositAddress !== undefined ? message.depositAddress : new Uint8Array()));
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    create(base) {
        return ConfirmDepositRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConfirmDepositRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.depositAddress = object.depositAddress ?? new Uint8Array();
        message.denom = object.denom ?? "";
        return message;
    },
};
function createBaseConfirmDepositResponse() {
    return {};
}
export const ConfirmDepositResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConfirmDepositResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return ConfirmDepositResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseConfirmDepositResponse();
        return message;
    },
};
function createBaseExecutePendingTransfersRequest() {
    return { sender: new Uint8Array() };
}
export const ExecutePendingTransfersRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExecutePendingTransfersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array() };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        return obj;
    },
    create(base) {
        return ExecutePendingTransfersRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExecutePendingTransfersRequest();
        message.sender = object.sender ?? new Uint8Array();
        return message;
    },
};
function createBaseExecutePendingTransfersResponse() {
    return {};
}
export const ExecutePendingTransfersResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExecutePendingTransfersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return ExecutePendingTransfersResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseExecutePendingTransfersResponse();
        return message;
    },
};
function createBaseRegisterIBCPathRequest() {
    return { sender: new Uint8Array(), chain: "", path: "" };
}
export const RegisterIBCPathRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        if (message.path !== "") {
            writer.uint32(26).string(message.path);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterIBCPathRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.chain = reader.string();
                    break;
                case 3:
                    message.path = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            chain: isSet(object.chain) ? String(object.chain) : "",
            path: isSet(object.path) ? String(object.path) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.chain !== undefined && (obj.chain = message.chain);
        message.path !== undefined && (obj.path = message.path);
        return obj;
    },
    create(base) {
        return RegisterIBCPathRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRegisterIBCPathRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.chain = object.chain ?? "";
        message.path = object.path ?? "";
        return message;
    },
};
function createBaseRegisterIBCPathResponse() {
    return {};
}
export const RegisterIBCPathResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterIBCPathResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RegisterIBCPathResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRegisterIBCPathResponse();
        return message;
    },
};
function createBaseAddCosmosBasedChainRequest() {
    return { sender: new Uint8Array(), chain: undefined, addrPrefix: "", nativeAssets: [], cosmosChain: "", ibcPath: "" };
}
export const AddCosmosBasedChainRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.chain !== undefined) {
            Chain.encode(message.chain, writer.uint32(18).fork()).ldelim();
        }
        if (message.addrPrefix !== "") {
            writer.uint32(26).string(message.addrPrefix);
        }
        for (const v of message.nativeAssets) {
            Asset.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.cosmosChain !== "") {
            writer.uint32(50).string(message.cosmosChain);
        }
        if (message.ibcPath !== "") {
            writer.uint32(58).string(message.ibcPath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddCosmosBasedChainRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.chain = Chain.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.addrPrefix = reader.string();
                    break;
                case 5:
                    message.nativeAssets.push(Asset.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.cosmosChain = reader.string();
                    break;
                case 7:
                    message.ibcPath = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            chain: isSet(object.chain) ? Chain.fromJSON(object.chain) : undefined,
            addrPrefix: isSet(object.addrPrefix) ? String(object.addrPrefix) : "",
            nativeAssets: Array.isArray(object?.nativeAssets) ? object.nativeAssets.map((e) => Asset.fromJSON(e)) : [],
            cosmosChain: isSet(object.cosmosChain) ? String(object.cosmosChain) : "",
            ibcPath: isSet(object.ibcPath) ? String(object.ibcPath) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.chain !== undefined && (obj.chain = message.chain ? Chain.toJSON(message.chain) : undefined);
        message.addrPrefix !== undefined && (obj.addrPrefix = message.addrPrefix);
        if (message.nativeAssets) {
            obj.nativeAssets = message.nativeAssets.map((e) => e ? Asset.toJSON(e) : undefined);
        }
        else {
            obj.nativeAssets = [];
        }
        message.cosmosChain !== undefined && (obj.cosmosChain = message.cosmosChain);
        message.ibcPath !== undefined && (obj.ibcPath = message.ibcPath);
        return obj;
    },
    create(base) {
        return AddCosmosBasedChainRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddCosmosBasedChainRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.chain = (object.chain !== undefined && object.chain !== null) ? Chain.fromPartial(object.chain) : undefined;
        message.addrPrefix = object.addrPrefix ?? "";
        message.nativeAssets = object.nativeAssets?.map((e) => Asset.fromPartial(e)) || [];
        message.cosmosChain = object.cosmosChain ?? "";
        message.ibcPath = object.ibcPath ?? "";
        return message;
    },
};
function createBaseAddCosmosBasedChainResponse() {
    return {};
}
export const AddCosmosBasedChainResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddCosmosBasedChainResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return AddCosmosBasedChainResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseAddCosmosBasedChainResponse();
        return message;
    },
};
function createBaseRegisterAssetRequest() {
    return { sender: new Uint8Array(), chain: "", asset: undefined, limit: new Uint8Array(), window: undefined };
}
export const RegisterAssetRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        if (message.asset !== undefined) {
            Asset.encode(message.asset, writer.uint32(26).fork()).ldelim();
        }
        if (message.limit.length !== 0) {
            writer.uint32(34).bytes(message.limit);
        }
        if (message.window !== undefined) {
            Duration.encode(message.window, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterAssetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.chain = reader.string();
                    break;
                case 3:
                    message.asset = Asset.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.limit = reader.bytes();
                    break;
                case 5:
                    message.window = Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            chain: isSet(object.chain) ? String(object.chain) : "",
            asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
            limit: isSet(object.limit) ? bytesFromBase64(object.limit) : new Uint8Array(),
            window: isSet(object.window) ? Duration.fromJSON(object.window) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.chain !== undefined && (obj.chain = message.chain);
        message.asset !== undefined && (obj.asset = message.asset ? Asset.toJSON(message.asset) : undefined);
        message.limit !== undefined &&
            (obj.limit = base64FromBytes(message.limit !== undefined ? message.limit : new Uint8Array()));
        message.window !== undefined && (obj.window = message.window ? Duration.toJSON(message.window) : undefined);
        return obj;
    },
    create(base) {
        return RegisterAssetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRegisterAssetRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.chain = object.chain ?? "";
        message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
        message.limit = object.limit ?? new Uint8Array();
        message.window = (object.window !== undefined && object.window !== null)
            ? Duration.fromPartial(object.window)
            : undefined;
        return message;
    },
};
function createBaseRegisterAssetResponse() {
    return {};
}
export const RegisterAssetResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterAssetResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RegisterAssetResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRegisterAssetResponse();
        return message;
    },
};
function createBaseRouteIBCTransfersRequest() {
    return { sender: new Uint8Array() };
}
export const RouteIBCTransfersRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRouteIBCTransfersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array() };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        return obj;
    },
    create(base) {
        return RouteIBCTransfersRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRouteIBCTransfersRequest();
        message.sender = object.sender ?? new Uint8Array();
        return message;
    },
};
function createBaseRouteIBCTransfersResponse() {
    return {};
}
export const RouteIBCTransfersResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRouteIBCTransfersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RouteIBCTransfersResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRouteIBCTransfersResponse();
        return message;
    },
};
function createBaseRegisterFeeCollectorRequest() {
    return { sender: new Uint8Array(), feeCollector: new Uint8Array() };
}
export const RegisterFeeCollectorRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.feeCollector.length !== 0) {
            writer.uint32(18).bytes(message.feeCollector);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterFeeCollectorRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.feeCollector = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            feeCollector: isSet(object.feeCollector) ? bytesFromBase64(object.feeCollector) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.feeCollector !== undefined &&
            (obj.feeCollector = base64FromBytes(message.feeCollector !== undefined ? message.feeCollector : new Uint8Array()));
        return obj;
    },
    create(base) {
        return RegisterFeeCollectorRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRegisterFeeCollectorRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.feeCollector = object.feeCollector ?? new Uint8Array();
        return message;
    },
};
function createBaseRegisterFeeCollectorResponse() {
    return {};
}
export const RegisterFeeCollectorResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterFeeCollectorResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RegisterFeeCollectorResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRegisterFeeCollectorResponse();
        return message;
    },
};
function createBaseRetryIBCTransferRequest() {
    return { sender: new Uint8Array(), chain: "", id: Long.UZERO };
}
export const RetryIBCTransferRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        if (!message.id.isZero()) {
            writer.uint32(24).uint64(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRetryIBCTransferRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.chain = reader.string();
                    break;
                case 3:
                    message.id = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            chain: isSet(object.chain) ? String(object.chain) : "",
            id: isSet(object.id) ? Long.fromValue(object.id) : Long.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.chain !== undefined && (obj.chain = message.chain);
        message.id !== undefined && (obj.id = (message.id || Long.UZERO).toString());
        return obj;
    },
    create(base) {
        return RetryIBCTransferRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRetryIBCTransferRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.chain = object.chain ?? "";
        message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.UZERO;
        return message;
    },
};
function createBaseRetryIBCTransferResponse() {
    return {};
}
export const RetryIBCTransferResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRetryIBCTransferResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RetryIBCTransferResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRetryIBCTransferResponse();
        return message;
    },
};
function createBaseRouteMessageRequest() {
    return { sender: new Uint8Array(), id: "", payload: new Uint8Array() };
}
export const RouteMessageRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.payload.length !== 0) {
            writer.uint32(26).bytes(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRouteMessageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            id: isSet(object.id) ? String(object.id) : "",
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.id !== undefined && (obj.id = message.id);
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        return obj;
    },
    create(base) {
        return RouteMessageRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRouteMessageRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.id = object.id ?? "";
        message.payload = object.payload ?? new Uint8Array();
        return message;
    },
};
function createBaseRouteMessageResponse() {
    return {};
}
export const RouteMessageResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRouteMessageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RouteMessageResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRouteMessageResponse();
        return message;
    },
};
function createBaseCallContractRequest() {
    return { sender: new Uint8Array(), chain: "", contractAddress: "", payload: new Uint8Array(), fee: undefined };
}
export const CallContractRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.sender.length !== 0) {
            writer.uint32(10).bytes(message.sender);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        if (message.contractAddress !== "") {
            writer.uint32(26).string(message.contractAddress);
        }
        if (message.payload.length !== 0) {
            writer.uint32(34).bytes(message.payload);
        }
        if (message.fee !== undefined) {
            Fee.encode(message.fee, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCallContractRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sender = reader.bytes();
                    break;
                case 2:
                    message.chain = reader.string();
                    break;
                case 3:
                    message.contractAddress = reader.string();
                    break;
                case 4:
                    message.payload = reader.bytes();
                    break;
                case 5:
                    message.fee = Fee.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? bytesFromBase64(object.sender) : new Uint8Array(),
            chain: isSet(object.chain) ? String(object.chain) : "",
            contractAddress: isSet(object.contractAddress) ? String(object.contractAddress) : "",
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
            fee: isSet(object.fee) ? Fee.fromJSON(object.fee) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.sender !== undefined &&
            (obj.sender = base64FromBytes(message.sender !== undefined ? message.sender : new Uint8Array()));
        message.chain !== undefined && (obj.chain = message.chain);
        message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);
        message.payload !== undefined &&
            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        message.fee !== undefined && (obj.fee = message.fee ? Fee.toJSON(message.fee) : undefined);
        return obj;
    },
    create(base) {
        return CallContractRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCallContractRequest();
        message.sender = object.sender ?? new Uint8Array();
        message.chain = object.chain ?? "";
        message.contractAddress = object.contractAddress ?? "";
        message.payload = object.payload ?? new Uint8Array();
        message.fee = (object.fee !== undefined && object.fee !== null) ? Fee.fromPartial(object.fee) : undefined;
        return message;
    },
};
function createBaseCallContractResponse() {
    return {};
}
export const CallContractResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCallContractResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return CallContractResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseCallContractResponse();
        return message;
    },
};
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis.Buffer) {
        return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis.btoa(bin.join(""));
    }
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
