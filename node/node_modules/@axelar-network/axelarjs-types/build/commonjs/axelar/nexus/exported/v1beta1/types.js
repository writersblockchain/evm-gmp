"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneralMessage = exports.Asset = exports.FeeInfo = exports.TransferFee = exports.CrossChainTransfer = exports.CrossChainAddress = exports.Chain = exports.generalMessage_StatusToJSON = exports.generalMessage_StatusFromJSON = exports.GeneralMessage_Status = exports.transferDirectionToJSON = exports.transferDirectionFromJSON = exports.TransferDirection = exports.transferStateToJSON = exports.transferStateFromJSON = exports.TransferState = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../../../cosmos/base/v1beta1/coin");
const types_1 = require("../../../tss/exported/v1beta1/types");
exports.protobufPackage = "axelar.nexus.exported.v1beta1";
var TransferState;
(function (TransferState) {
    TransferState[TransferState["TRANSFER_STATE_UNSPECIFIED"] = 0] = "TRANSFER_STATE_UNSPECIFIED";
    TransferState[TransferState["TRANSFER_STATE_PENDING"] = 1] = "TRANSFER_STATE_PENDING";
    TransferState[TransferState["TRANSFER_STATE_ARCHIVED"] = 2] = "TRANSFER_STATE_ARCHIVED";
    TransferState[TransferState["TRANSFER_STATE_INSUFFICIENT_AMOUNT"] = 3] = "TRANSFER_STATE_INSUFFICIENT_AMOUNT";
    TransferState[TransferState["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TransferState = exports.TransferState || (exports.TransferState = {}));
function transferStateFromJSON(object) {
    switch (object) {
        case 0:
        case "TRANSFER_STATE_UNSPECIFIED":
            return TransferState.TRANSFER_STATE_UNSPECIFIED;
        case 1:
        case "TRANSFER_STATE_PENDING":
            return TransferState.TRANSFER_STATE_PENDING;
        case 2:
        case "TRANSFER_STATE_ARCHIVED":
            return TransferState.TRANSFER_STATE_ARCHIVED;
        case 3:
        case "TRANSFER_STATE_INSUFFICIENT_AMOUNT":
            return TransferState.TRANSFER_STATE_INSUFFICIENT_AMOUNT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TransferState.UNRECOGNIZED;
    }
}
exports.transferStateFromJSON = transferStateFromJSON;
function transferStateToJSON(object) {
    switch (object) {
        case TransferState.TRANSFER_STATE_UNSPECIFIED:
            return "TRANSFER_STATE_UNSPECIFIED";
        case TransferState.TRANSFER_STATE_PENDING:
            return "TRANSFER_STATE_PENDING";
        case TransferState.TRANSFER_STATE_ARCHIVED:
            return "TRANSFER_STATE_ARCHIVED";
        case TransferState.TRANSFER_STATE_INSUFFICIENT_AMOUNT:
            return "TRANSFER_STATE_INSUFFICIENT_AMOUNT";
        case TransferState.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.transferStateToJSON = transferStateToJSON;
var TransferDirection;
(function (TransferDirection) {
    TransferDirection[TransferDirection["TRANSFER_DIRECTION_UNSPECIFIED"] = 0] = "TRANSFER_DIRECTION_UNSPECIFIED";
    TransferDirection[TransferDirection["TRANSFER_DIRECTION_INCOMING"] = 1] = "TRANSFER_DIRECTION_INCOMING";
    TransferDirection[TransferDirection["TRANSFER_DIRECTION_OUTGOING"] = 2] = "TRANSFER_DIRECTION_OUTGOING";
    TransferDirection[TransferDirection["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TransferDirection = exports.TransferDirection || (exports.TransferDirection = {}));
function transferDirectionFromJSON(object) {
    switch (object) {
        case 0:
        case "TRANSFER_DIRECTION_UNSPECIFIED":
            return TransferDirection.TRANSFER_DIRECTION_UNSPECIFIED;
        case 1:
        case "TRANSFER_DIRECTION_INCOMING":
            return TransferDirection.TRANSFER_DIRECTION_INCOMING;
        case 2:
        case "TRANSFER_DIRECTION_OUTGOING":
            return TransferDirection.TRANSFER_DIRECTION_OUTGOING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TransferDirection.UNRECOGNIZED;
    }
}
exports.transferDirectionFromJSON = transferDirectionFromJSON;
function transferDirectionToJSON(object) {
    switch (object) {
        case TransferDirection.TRANSFER_DIRECTION_UNSPECIFIED:
            return "TRANSFER_DIRECTION_UNSPECIFIED";
        case TransferDirection.TRANSFER_DIRECTION_INCOMING:
            return "TRANSFER_DIRECTION_INCOMING";
        case TransferDirection.TRANSFER_DIRECTION_OUTGOING:
            return "TRANSFER_DIRECTION_OUTGOING";
        case TransferDirection.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.transferDirectionToJSON = transferDirectionToJSON;
var GeneralMessage_Status;
(function (GeneralMessage_Status) {
    GeneralMessage_Status[GeneralMessage_Status["STATUS_UNSPECIFIED"] = 0] = "STATUS_UNSPECIFIED";
    GeneralMessage_Status[GeneralMessage_Status["STATUS_APPROVED"] = 1] = "STATUS_APPROVED";
    GeneralMessage_Status[GeneralMessage_Status["STATUS_PROCESSING"] = 2] = "STATUS_PROCESSING";
    GeneralMessage_Status[GeneralMessage_Status["STATUS_EXECUTED"] = 3] = "STATUS_EXECUTED";
    GeneralMessage_Status[GeneralMessage_Status["STATUS_FAILED"] = 4] = "STATUS_FAILED";
    GeneralMessage_Status[GeneralMessage_Status["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GeneralMessage_Status = exports.GeneralMessage_Status || (exports.GeneralMessage_Status = {}));
function generalMessage_StatusFromJSON(object) {
    switch (object) {
        case 0:
        case "STATUS_UNSPECIFIED":
            return GeneralMessage_Status.STATUS_UNSPECIFIED;
        case 1:
        case "STATUS_APPROVED":
            return GeneralMessage_Status.STATUS_APPROVED;
        case 2:
        case "STATUS_PROCESSING":
            return GeneralMessage_Status.STATUS_PROCESSING;
        case 3:
        case "STATUS_EXECUTED":
            return GeneralMessage_Status.STATUS_EXECUTED;
        case 4:
        case "STATUS_FAILED":
            return GeneralMessage_Status.STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return GeneralMessage_Status.UNRECOGNIZED;
    }
}
exports.generalMessage_StatusFromJSON = generalMessage_StatusFromJSON;
function generalMessage_StatusToJSON(object) {
    switch (object) {
        case GeneralMessage_Status.STATUS_UNSPECIFIED:
            return "STATUS_UNSPECIFIED";
        case GeneralMessage_Status.STATUS_APPROVED:
            return "STATUS_APPROVED";
        case GeneralMessage_Status.STATUS_PROCESSING:
            return "STATUS_PROCESSING";
        case GeneralMessage_Status.STATUS_EXECUTED:
            return "STATUS_EXECUTED";
        case GeneralMessage_Status.STATUS_FAILED:
            return "STATUS_FAILED";
        case GeneralMessage_Status.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.generalMessage_StatusToJSON = generalMessage_StatusToJSON;
function createBaseChain() {
    return { name: "", supportsForeignAssets: false, keyType: 0, module: "" };
}
exports.Chain = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.supportsForeignAssets === true) {
            writer.uint32(24).bool(message.supportsForeignAssets);
        }
        if (message.keyType !== 0) {
            writer.uint32(32).int32(message.keyType);
        }
        if (message.module !== "") {
            writer.uint32(42).string(message.module);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChain();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 3:
                    message.supportsForeignAssets = reader.bool();
                    break;
                case 4:
                    message.keyType = reader.int32();
                    break;
                case 5:
                    message.module = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            supportsForeignAssets: isSet(object.supportsForeignAssets) ? Boolean(object.supportsForeignAssets) : false,
            keyType: isSet(object.keyType) ? (0, types_1.keyTypeFromJSON)(object.keyType) : 0,
            module: isSet(object.module) ? String(object.module) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.supportsForeignAssets !== undefined && (obj.supportsForeignAssets = message.supportsForeignAssets);
        message.keyType !== undefined && (obj.keyType = (0, types_1.keyTypeToJSON)(message.keyType));
        message.module !== undefined && (obj.module = message.module);
        return obj;
    },
    create(base) {
        return exports.Chain.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChain();
        message.name = object.name ?? "";
        message.supportsForeignAssets = object.supportsForeignAssets ?? false;
        message.keyType = object.keyType ?? 0;
        message.module = object.module ?? "";
        return message;
    },
};
function createBaseCrossChainAddress() {
    return { chain: undefined, address: "" };
}
exports.CrossChainAddress = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== undefined) {
            exports.Chain.encode(message.chain, writer.uint32(10).fork()).ldelim();
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrossChainAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = exports.Chain.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            chain: isSet(object.chain) ? exports.Chain.fromJSON(object.chain) : undefined,
            address: isSet(object.address) ? String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain ? exports.Chain.toJSON(message.chain) : undefined);
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    create(base) {
        return exports.CrossChainAddress.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrossChainAddress();
        message.chain = (object.chain !== undefined && object.chain !== null) ? exports.Chain.fromPartial(object.chain) : undefined;
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseCrossChainTransfer() {
    return { recipient: undefined, asset: undefined, id: long_1.default.UZERO, state: 0 };
}
exports.CrossChainTransfer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.recipient !== undefined) {
            exports.CrossChainAddress.encode(message.recipient, writer.uint32(10).fork()).ldelim();
        }
        if (message.asset !== undefined) {
            coin_1.Coin.encode(message.asset, writer.uint32(18).fork()).ldelim();
        }
        if (!message.id.isZero()) {
            writer.uint32(24).uint64(message.id);
        }
        if (message.state !== 0) {
            writer.uint32(32).int32(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCrossChainTransfer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.recipient = exports.CrossChainAddress.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.asset = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.id = reader.uint64();
                    break;
                case 4:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            recipient: isSet(object.recipient) ? exports.CrossChainAddress.fromJSON(object.recipient) : undefined,
            asset: isSet(object.asset) ? coin_1.Coin.fromJSON(object.asset) : undefined,
            id: isSet(object.id) ? long_1.default.fromValue(object.id) : long_1.default.UZERO,
            state: isSet(object.state) ? transferStateFromJSON(object.state) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.recipient !== undefined &&
            (obj.recipient = message.recipient ? exports.CrossChainAddress.toJSON(message.recipient) : undefined);
        message.asset !== undefined && (obj.asset = message.asset ? coin_1.Coin.toJSON(message.asset) : undefined);
        message.id !== undefined && (obj.id = (message.id || long_1.default.UZERO).toString());
        message.state !== undefined && (obj.state = transferStateToJSON(message.state));
        return obj;
    },
    create(base) {
        return exports.CrossChainTransfer.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCrossChainTransfer();
        message.recipient = (object.recipient !== undefined && object.recipient !== null)
            ? exports.CrossChainAddress.fromPartial(object.recipient)
            : undefined;
        message.asset = (object.asset !== undefined && object.asset !== null) ? coin_1.Coin.fromPartial(object.asset) : undefined;
        message.id = (object.id !== undefined && object.id !== null) ? long_1.default.fromValue(object.id) : long_1.default.UZERO;
        message.state = object.state ?? 0;
        return message;
    },
};
function createBaseTransferFee() {
    return { coins: [] };
}
exports.TransferFee = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.coins) {
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferFee();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { coins: Array.isArray(object?.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.coins) {
            obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);
        }
        else {
            obj.coins = [];
        }
        return obj;
    },
    create(base) {
        return exports.TransferFee.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferFee();
        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFeeInfo() {
    return { chain: "", asset: "", feeRate: new Uint8Array(), minFee: new Uint8Array(), maxFee: new Uint8Array() };
}
exports.FeeInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.asset !== "") {
            writer.uint32(18).string(message.asset);
        }
        if (message.feeRate.length !== 0) {
            writer.uint32(26).bytes(message.feeRate);
        }
        if (message.minFee.length !== 0) {
            writer.uint32(34).bytes(message.minFee);
        }
        if (message.maxFee.length !== 0) {
            writer.uint32(42).bytes(message.maxFee);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFeeInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.asset = reader.string();
                    break;
                case 3:
                    message.feeRate = reader.bytes();
                    break;
                case 4:
                    message.minFee = reader.bytes();
                    break;
                case 5:
                    message.maxFee = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            chain: isSet(object.chain) ? String(object.chain) : "",
            asset: isSet(object.asset) ? String(object.asset) : "",
            feeRate: isSet(object.feeRate) ? bytesFromBase64(object.feeRate) : new Uint8Array(),
            minFee: isSet(object.minFee) ? bytesFromBase64(object.minFee) : new Uint8Array(),
            maxFee: isSet(object.maxFee) ? bytesFromBase64(object.maxFee) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        message.asset !== undefined && (obj.asset = message.asset);
        message.feeRate !== undefined &&
            (obj.feeRate = base64FromBytes(message.feeRate !== undefined ? message.feeRate : new Uint8Array()));
        message.minFee !== undefined &&
            (obj.minFee = base64FromBytes(message.minFee !== undefined ? message.minFee : new Uint8Array()));
        message.maxFee !== undefined &&
            (obj.maxFee = base64FromBytes(message.maxFee !== undefined ? message.maxFee : new Uint8Array()));
        return obj;
    },
    create(base) {
        return exports.FeeInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFeeInfo();
        message.chain = object.chain ?? "";
        message.asset = object.asset ?? "";
        message.feeRate = object.feeRate ?? new Uint8Array();
        message.minFee = object.minFee ?? new Uint8Array();
        message.maxFee = object.maxFee ?? new Uint8Array();
        return message;
    },
};
function createBaseAsset() {
    return { denom: "", isNativeAsset: false };
}
exports.Asset = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.isNativeAsset === true) {
            writer.uint32(24).bool(message.isNativeAsset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAsset();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 3:
                    message.isNativeAsset = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? String(object.denom) : "",
            isNativeAsset: isSet(object.isNativeAsset) ? Boolean(object.isNativeAsset) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.isNativeAsset !== undefined && (obj.isNativeAsset = message.isNativeAsset);
        return obj;
    },
    create(base) {
        return exports.Asset.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAsset();
        message.denom = object.denom ?? "";
        message.isNativeAsset = object.isNativeAsset ?? false;
        return message;
    },
};
function createBaseGeneralMessage() {
    return {
        id: "",
        sender: undefined,
        recipient: undefined,
        payloadHash: new Uint8Array(),
        status: 0,
        asset: undefined,
        sourceTxId: new Uint8Array(),
        sourceTxIndex: long_1.default.UZERO,
    };
}
exports.GeneralMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.sender !== undefined) {
            exports.CrossChainAddress.encode(message.sender, writer.uint32(18).fork()).ldelim();
        }
        if (message.recipient !== undefined) {
            exports.CrossChainAddress.encode(message.recipient, writer.uint32(26).fork()).ldelim();
        }
        if (message.payloadHash.length !== 0) {
            writer.uint32(34).bytes(message.payloadHash);
        }
        if (message.status !== 0) {
            writer.uint32(40).int32(message.status);
        }
        if (message.asset !== undefined) {
            coin_1.Coin.encode(message.asset, writer.uint32(50).fork()).ldelim();
        }
        if (message.sourceTxId.length !== 0) {
            writer.uint32(58).bytes(message.sourceTxId);
        }
        if (!message.sourceTxIndex.isZero()) {
            writer.uint32(64).uint64(message.sourceTxIndex);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGeneralMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.sender = exports.CrossChainAddress.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.recipient = exports.CrossChainAddress.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.payloadHash = reader.bytes();
                    break;
                case 5:
                    message.status = reader.int32();
                    break;
                case 6:
                    message.asset = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.sourceTxId = reader.bytes();
                    break;
                case 8:
                    message.sourceTxIndex = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            sender: isSet(object.sender) ? exports.CrossChainAddress.fromJSON(object.sender) : undefined,
            recipient: isSet(object.recipient) ? exports.CrossChainAddress.fromJSON(object.recipient) : undefined,
            payloadHash: isSet(object.payloadHash) ? bytesFromBase64(object.payloadHash) : new Uint8Array(),
            status: isSet(object.status) ? generalMessage_StatusFromJSON(object.status) : 0,
            asset: isSet(object.asset) ? coin_1.Coin.fromJSON(object.asset) : undefined,
            sourceTxId: isSet(object.sourceTxId) ? bytesFromBase64(object.sourceTxId) : new Uint8Array(),
            sourceTxIndex: isSet(object.sourceTxIndex) ? long_1.default.fromValue(object.sourceTxIndex) : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.sender !== undefined &&
            (obj.sender = message.sender ? exports.CrossChainAddress.toJSON(message.sender) : undefined);
        message.recipient !== undefined &&
            (obj.recipient = message.recipient ? exports.CrossChainAddress.toJSON(message.recipient) : undefined);
        message.payloadHash !== undefined &&
            (obj.payloadHash = base64FromBytes(message.payloadHash !== undefined ? message.payloadHash : new Uint8Array()));
        message.status !== undefined && (obj.status = generalMessage_StatusToJSON(message.status));
        message.asset !== undefined && (obj.asset = message.asset ? coin_1.Coin.toJSON(message.asset) : undefined);
        message.sourceTxId !== undefined &&
            (obj.sourceTxId = base64FromBytes(message.sourceTxId !== undefined ? message.sourceTxId : new Uint8Array()));
        message.sourceTxIndex !== undefined && (obj.sourceTxIndex = (message.sourceTxIndex || long_1.default.UZERO).toString());
        return obj;
    },
    create(base) {
        return exports.GeneralMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGeneralMessage();
        message.id = object.id ?? "";
        message.sender = (object.sender !== undefined && object.sender !== null)
            ? exports.CrossChainAddress.fromPartial(object.sender)
            : undefined;
        message.recipient = (object.recipient !== undefined && object.recipient !== null)
            ? exports.CrossChainAddress.fromPartial(object.recipient)
            : undefined;
        message.payloadHash = object.payloadHash ?? new Uint8Array();
        message.status = object.status ?? 0;
        message.asset = (object.asset !== undefined && object.asset !== null) ? coin_1.Coin.fromPartial(object.asset) : undefined;
        message.sourceTxId = object.sourceTxId ?? new Uint8Array();
        message.sourceTxIndex = (object.sourceTxIndex !== undefined && object.sourceTxIndex !== null)
            ? long_1.default.fromValue(object.sourceTxIndex)
            : long_1.default.UZERO;
        return message;
    },
};
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis.Buffer) {
        return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis.btoa(bin.join(""));
    }
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
