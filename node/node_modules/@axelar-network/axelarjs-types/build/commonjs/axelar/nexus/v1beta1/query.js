"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageResponse = exports.MessageRequest = exports.TransferRateLimit = exports.TransferRateLimitResponse = exports.TransferRateLimitRequest = exports.RecipientAddressResponse = exports.RecipientAddressRequest = exports.ChainsByAssetResponse = exports.ChainsByAssetRequest = exports.ChainStateResponse = exports.ChainStateRequest = exports.AssetsResponse = exports.AssetsRequest = exports.ChainsResponse = exports.ChainsRequest = exports.TransferFeeResponse = exports.TransferFeeRequest = exports.FeeInfoResponse = exports.FeeInfoRequest = exports.TransfersForChainResponse = exports.TransfersForChainRequest = exports.LatestDepositAddressResponse = exports.LatestDepositAddressRequest = exports.ChainMaintainersResponse = exports.ChainMaintainersRequest = exports.chainStatusToJSON = exports.chainStatusFromJSON = exports.ChainStatus = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const pagination_1 = require("../../../cosmos/base/query/v1beta1/pagination");
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
const duration_1 = require("../../../google/protobuf/duration");
const types_1 = require("../exported/v1beta1/types");
const types_2 = require("./types");
exports.protobufPackage = "axelar.nexus.v1beta1";
var ChainStatus;
(function (ChainStatus) {
    ChainStatus[ChainStatus["CHAIN_STATUS_UNSPECIFIED"] = 0] = "CHAIN_STATUS_UNSPECIFIED";
    ChainStatus[ChainStatus["CHAIN_STATUS_ACTIVATED"] = 1] = "CHAIN_STATUS_ACTIVATED";
    ChainStatus[ChainStatus["CHAIN_STATUS_DEACTIVATED"] = 2] = "CHAIN_STATUS_DEACTIVATED";
    ChainStatus[ChainStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ChainStatus = exports.ChainStatus || (exports.ChainStatus = {}));
function chainStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "CHAIN_STATUS_UNSPECIFIED":
            return ChainStatus.CHAIN_STATUS_UNSPECIFIED;
        case 1:
        case "CHAIN_STATUS_ACTIVATED":
            return ChainStatus.CHAIN_STATUS_ACTIVATED;
        case 2:
        case "CHAIN_STATUS_DEACTIVATED":
            return ChainStatus.CHAIN_STATUS_DEACTIVATED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ChainStatus.UNRECOGNIZED;
    }
}
exports.chainStatusFromJSON = chainStatusFromJSON;
function chainStatusToJSON(object) {
    switch (object) {
        case ChainStatus.CHAIN_STATUS_UNSPECIFIED:
            return "CHAIN_STATUS_UNSPECIFIED";
        case ChainStatus.CHAIN_STATUS_ACTIVATED:
            return "CHAIN_STATUS_ACTIVATED";
        case ChainStatus.CHAIN_STATUS_DEACTIVATED:
            return "CHAIN_STATUS_DEACTIVATED";
        case ChainStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.chainStatusToJSON = chainStatusToJSON;
function createBaseChainMaintainersRequest() {
    return { chain: "" };
}
exports.ChainMaintainersRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainMaintainersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chain: isSet(object.chain) ? String(object.chain) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        return obj;
    },
    create(base) {
        return exports.ChainMaintainersRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainMaintainersRequest();
        message.chain = object.chain ?? "";
        return message;
    },
};
function createBaseChainMaintainersResponse() {
    return { maintainers: [] };
}
exports.ChainMaintainersResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.maintainers) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainMaintainersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.maintainers.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            maintainers: Array.isArray(object?.maintainers) ? object.maintainers.map((e) => bytesFromBase64(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.maintainers) {
            obj.maintainers = message.maintainers.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));
        }
        else {
            obj.maintainers = [];
        }
        return obj;
    },
    create(base) {
        return exports.ChainMaintainersResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainMaintainersResponse();
        message.maintainers = object.maintainers?.map((e) => e) || [];
        return message;
    },
};
function createBaseLatestDepositAddressRequest() {
    return { recipientAddr: "", recipientChain: "", depositChain: "" };
}
exports.LatestDepositAddressRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.recipientAddr !== "") {
            writer.uint32(10).string(message.recipientAddr);
        }
        if (message.recipientChain !== "") {
            writer.uint32(18).string(message.recipientChain);
        }
        if (message.depositChain !== "") {
            writer.uint32(26).string(message.depositChain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLatestDepositAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.recipientAddr = reader.string();
                    break;
                case 2:
                    message.recipientChain = reader.string();
                    break;
                case 3:
                    message.depositChain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            recipientAddr: isSet(object.recipientAddr) ? String(object.recipientAddr) : "",
            recipientChain: isSet(object.recipientChain) ? String(object.recipientChain) : "",
            depositChain: isSet(object.depositChain) ? String(object.depositChain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.recipientAddr !== undefined && (obj.recipientAddr = message.recipientAddr);
        message.recipientChain !== undefined && (obj.recipientChain = message.recipientChain);
        message.depositChain !== undefined && (obj.depositChain = message.depositChain);
        return obj;
    },
    create(base) {
        return exports.LatestDepositAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLatestDepositAddressRequest();
        message.recipientAddr = object.recipientAddr ?? "";
        message.recipientChain = object.recipientChain ?? "";
        message.depositChain = object.depositChain ?? "";
        return message;
    },
};
function createBaseLatestDepositAddressResponse() {
    return { depositAddr: "" };
}
exports.LatestDepositAddressResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.depositAddr !== "") {
            writer.uint32(10).string(message.depositAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLatestDepositAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.depositAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { depositAddr: isSet(object.depositAddr) ? String(object.depositAddr) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.depositAddr !== undefined && (obj.depositAddr = message.depositAddr);
        return obj;
    },
    create(base) {
        return exports.LatestDepositAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLatestDepositAddressResponse();
        message.depositAddr = object.depositAddr ?? "";
        return message;
    },
};
function createBaseTransfersForChainRequest() {
    return { chain: "", state: 0, pagination: undefined };
}
exports.TransfersForChainRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.state !== 0) {
            writer.uint32(16).int32(message.state);
        }
        if (message.pagination !== undefined) {
            pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransfersForChainRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.state = reader.int32();
                    break;
                case 3:
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            chain: isSet(object.chain) ? String(object.chain) : "",
            state: isSet(object.state) ? (0, types_1.transferStateFromJSON)(object.state) : 0,
            pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        message.state !== undefined && (obj.state = (0, types_1.transferStateToJSON)(message.state));
        message.pagination !== undefined &&
            (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : undefined);
        return obj;
    },
    create(base) {
        return exports.TransfersForChainRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransfersForChainRequest();
        message.chain = object.chain ?? "";
        message.state = object.state ?? 0;
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? pagination_1.PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseTransfersForChainResponse() {
    return { transfers: [], pagination: undefined };
}
exports.TransfersForChainResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.transfers) {
            types_1.CrossChainTransfer.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransfersForChainResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transfers.push(types_1.CrossChainTransfer.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            transfers: Array.isArray(object?.transfers)
                ? object.transfers.map((e) => types_1.CrossChainTransfer.fromJSON(e))
                : [],
            pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.transfers) {
            obj.transfers = message.transfers.map((e) => e ? types_1.CrossChainTransfer.toJSON(e) : undefined);
        }
        else {
            obj.transfers = [];
        }
        message.pagination !== undefined &&
            (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : undefined);
        return obj;
    },
    create(base) {
        return exports.TransfersForChainResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransfersForChainResponse();
        message.transfers = object.transfers?.map((e) => types_1.CrossChainTransfer.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? pagination_1.PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseFeeInfoRequest() {
    return { chain: "", asset: "" };
}
exports.FeeInfoRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.asset !== "") {
            writer.uint32(18).string(message.asset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFeeInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.asset = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            chain: isSet(object.chain) ? String(object.chain) : "",
            asset: isSet(object.asset) ? String(object.asset) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        message.asset !== undefined && (obj.asset = message.asset);
        return obj;
    },
    create(base) {
        return exports.FeeInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFeeInfoRequest();
        message.chain = object.chain ?? "";
        message.asset = object.asset ?? "";
        return message;
    },
};
function createBaseFeeInfoResponse() {
    return { feeInfo: undefined };
}
exports.FeeInfoResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.feeInfo !== undefined) {
            types_1.FeeInfo.encode(message.feeInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFeeInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.feeInfo = types_1.FeeInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { feeInfo: isSet(object.feeInfo) ? types_1.FeeInfo.fromJSON(object.feeInfo) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.feeInfo !== undefined && (obj.feeInfo = message.feeInfo ? types_1.FeeInfo.toJSON(message.feeInfo) : undefined);
        return obj;
    },
    create(base) {
        return exports.FeeInfoResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFeeInfoResponse();
        message.feeInfo = (object.feeInfo !== undefined && object.feeInfo !== null)
            ? types_1.FeeInfo.fromPartial(object.feeInfo)
            : undefined;
        return message;
    },
};
function createBaseTransferFeeRequest() {
    return { sourceChain: "", destinationChain: "", amount: "" };
}
exports.TransferFeeRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sourceChain !== "") {
            writer.uint32(10).string(message.sourceChain);
        }
        if (message.destinationChain !== "") {
            writer.uint32(18).string(message.destinationChain);
        }
        if (message.amount !== "") {
            writer.uint32(26).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferFeeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sourceChain = reader.string();
                    break;
                case 2:
                    message.destinationChain = reader.string();
                    break;
                case 3:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            sourceChain: isSet(object.sourceChain) ? String(object.sourceChain) : "",
            destinationChain: isSet(object.destinationChain) ? String(object.destinationChain) : "",
            amount: isSet(object.amount) ? String(object.amount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.sourceChain !== undefined && (obj.sourceChain = message.sourceChain);
        message.destinationChain !== undefined && (obj.destinationChain = message.destinationChain);
        message.amount !== undefined && (obj.amount = message.amount);
        return obj;
    },
    create(base) {
        return exports.TransferFeeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferFeeRequest();
        message.sourceChain = object.sourceChain ?? "";
        message.destinationChain = object.destinationChain ?? "";
        message.amount = object.amount ?? "";
        return message;
    },
};
function createBaseTransferFeeResponse() {
    return { fee: undefined };
}
exports.TransferFeeResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.fee !== undefined) {
            coin_1.Coin.encode(message.fee, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferFeeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fee = coin_1.Coin.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { fee: isSet(object.fee) ? coin_1.Coin.fromJSON(object.fee) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.fee !== undefined && (obj.fee = message.fee ? coin_1.Coin.toJSON(message.fee) : undefined);
        return obj;
    },
    create(base) {
        return exports.TransferFeeResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferFeeResponse();
        message.fee = (object.fee !== undefined && object.fee !== null) ? coin_1.Coin.fromPartial(object.fee) : undefined;
        return message;
    },
};
function createBaseChainsRequest() {
    return { status: 0 };
}
exports.ChainsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status !== 0) {
            writer.uint32(8).int32(message.status);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { status: isSet(object.status) ? chainStatusFromJSON(object.status) : 0 };
    },
    toJSON(message) {
        const obj = {};
        message.status !== undefined && (obj.status = chainStatusToJSON(message.status));
        return obj;
    },
    create(base) {
        return exports.ChainsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainsRequest();
        message.status = object.status ?? 0;
        return message;
    },
};
function createBaseChainsResponse() {
    return { chains: [] };
}
exports.ChainsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.chains) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chains.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chains: Array.isArray(object?.chains) ? object.chains.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.chains) {
            obj.chains = message.chains.map((e) => e);
        }
        else {
            obj.chains = [];
        }
        return obj;
    },
    create(base) {
        return exports.ChainsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainsResponse();
        message.chains = object.chains?.map((e) => e) || [];
        return message;
    },
};
function createBaseAssetsRequest() {
    return { chain: "" };
}
exports.AssetsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAssetsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chain: isSet(object.chain) ? String(object.chain) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        return obj;
    },
    create(base) {
        return exports.AssetsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAssetsRequest();
        message.chain = object.chain ?? "";
        return message;
    },
};
function createBaseAssetsResponse() {
    return { assets: [] };
}
exports.AssetsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.assets) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAssetsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.assets.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { assets: Array.isArray(object?.assets) ? object.assets.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.assets) {
            obj.assets = message.assets.map((e) => e);
        }
        else {
            obj.assets = [];
        }
        return obj;
    },
    create(base) {
        return exports.AssetsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAssetsResponse();
        message.assets = object.assets?.map((e) => e) || [];
        return message;
    },
};
function createBaseChainStateRequest() {
    return { chain: "" };
}
exports.ChainStateRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainStateRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chain: isSet(object.chain) ? String(object.chain) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        return obj;
    },
    create(base) {
        return exports.ChainStateRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainStateRequest();
        message.chain = object.chain ?? "";
        return message;
    },
};
function createBaseChainStateResponse() {
    return { state: undefined };
}
exports.ChainStateResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.state !== undefined) {
            types_2.ChainState.encode(message.state, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainStateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.state = types_2.ChainState.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { state: isSet(object.state) ? types_2.ChainState.fromJSON(object.state) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.state !== undefined && (obj.state = message.state ? types_2.ChainState.toJSON(message.state) : undefined);
        return obj;
    },
    create(base) {
        return exports.ChainStateResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainStateResponse();
        message.state = (object.state !== undefined && object.state !== null)
            ? types_2.ChainState.fromPartial(object.state)
            : undefined;
        return message;
    },
};
function createBaseChainsByAssetRequest() {
    return { asset: "" };
}
exports.ChainsByAssetRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.asset !== "") {
            writer.uint32(10).string(message.asset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainsByAssetRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.asset = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { asset: isSet(object.asset) ? String(object.asset) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.asset !== undefined && (obj.asset = message.asset);
        return obj;
    },
    create(base) {
        return exports.ChainsByAssetRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainsByAssetRequest();
        message.asset = object.asset ?? "";
        return message;
    },
};
function createBaseChainsByAssetResponse() {
    return { chains: [] };
}
exports.ChainsByAssetResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.chains) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChainsByAssetResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chains.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { chains: Array.isArray(object?.chains) ? object.chains.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.chains) {
            obj.chains = message.chains.map((e) => e);
        }
        else {
            obj.chains = [];
        }
        return obj;
    },
    create(base) {
        return exports.ChainsByAssetResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChainsByAssetResponse();
        message.chains = object.chains?.map((e) => e) || [];
        return message;
    },
};
function createBaseRecipientAddressRequest() {
    return { depositAddr: "", depositChain: "" };
}
exports.RecipientAddressRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.depositAddr !== "") {
            writer.uint32(10).string(message.depositAddr);
        }
        if (message.depositChain !== "") {
            writer.uint32(18).string(message.depositChain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecipientAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.depositAddr = reader.string();
                    break;
                case 2:
                    message.depositChain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            depositAddr: isSet(object.depositAddr) ? String(object.depositAddr) : "",
            depositChain: isSet(object.depositChain) ? String(object.depositChain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.depositAddr !== undefined && (obj.depositAddr = message.depositAddr);
        message.depositChain !== undefined && (obj.depositChain = message.depositChain);
        return obj;
    },
    create(base) {
        return exports.RecipientAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecipientAddressRequest();
        message.depositAddr = object.depositAddr ?? "";
        message.depositChain = object.depositChain ?? "";
        return message;
    },
};
function createBaseRecipientAddressResponse() {
    return { recipientAddr: "", recipientChain: "" };
}
exports.RecipientAddressResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.recipientAddr !== "") {
            writer.uint32(10).string(message.recipientAddr);
        }
        if (message.recipientChain !== "") {
            writer.uint32(18).string(message.recipientChain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecipientAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.recipientAddr = reader.string();
                    break;
                case 2:
                    message.recipientChain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            recipientAddr: isSet(object.recipientAddr) ? String(object.recipientAddr) : "",
            recipientChain: isSet(object.recipientChain) ? String(object.recipientChain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.recipientAddr !== undefined && (obj.recipientAddr = message.recipientAddr);
        message.recipientChain !== undefined && (obj.recipientChain = message.recipientChain);
        return obj;
    },
    create(base) {
        return exports.RecipientAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecipientAddressResponse();
        message.recipientAddr = object.recipientAddr ?? "";
        message.recipientChain = object.recipientChain ?? "";
        return message;
    },
};
function createBaseTransferRateLimitRequest() {
    return { chain: "", asset: "" };
}
exports.TransferRateLimitRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chain !== "") {
            writer.uint32(10).string(message.chain);
        }
        if (message.asset !== "") {
            writer.uint32(18).string(message.asset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferRateLimitRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.asset = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            chain: isSet(object.chain) ? String(object.chain) : "",
            asset: isSet(object.asset) ? String(object.asset) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.chain !== undefined && (obj.chain = message.chain);
        message.asset !== undefined && (obj.asset = message.asset);
        return obj;
    },
    create(base) {
        return exports.TransferRateLimitRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferRateLimitRequest();
        message.chain = object.chain ?? "";
        message.asset = object.asset ?? "";
        return message;
    },
};
function createBaseTransferRateLimitResponse() {
    return { transferRateLimit: undefined };
}
exports.TransferRateLimitResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.transferRateLimit !== undefined) {
            exports.TransferRateLimit.encode(message.transferRateLimit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferRateLimitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transferRateLimit = exports.TransferRateLimit.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            transferRateLimit: isSet(object.transferRateLimit)
                ? exports.TransferRateLimit.fromJSON(object.transferRateLimit)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.transferRateLimit !== undefined && (obj.transferRateLimit = message.transferRateLimit
            ? exports.TransferRateLimit.toJSON(message.transferRateLimit)
            : undefined);
        return obj;
    },
    create(base) {
        return exports.TransferRateLimitResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferRateLimitResponse();
        message.transferRateLimit = (object.transferRateLimit !== undefined && object.transferRateLimit !== null)
            ? exports.TransferRateLimit.fromPartial(object.transferRateLimit)
            : undefined;
        return message;
    },
};
function createBaseTransferRateLimit() {
    return {
        limit: new Uint8Array(),
        window: undefined,
        incoming: new Uint8Array(),
        outgoing: new Uint8Array(),
        timeLeft: undefined,
    };
}
exports.TransferRateLimit = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.limit.length !== 0) {
            writer.uint32(10).bytes(message.limit);
        }
        if (message.window !== undefined) {
            duration_1.Duration.encode(message.window, writer.uint32(18).fork()).ldelim();
        }
        if (message.incoming.length !== 0) {
            writer.uint32(26).bytes(message.incoming);
        }
        if (message.outgoing.length !== 0) {
            writer.uint32(34).bytes(message.outgoing);
        }
        if (message.timeLeft !== undefined) {
            duration_1.Duration.encode(message.timeLeft, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTransferRateLimit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.limit = reader.bytes();
                    break;
                case 2:
                    message.window = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.incoming = reader.bytes();
                    break;
                case 4:
                    message.outgoing = reader.bytes();
                    break;
                case 5:
                    message.timeLeft = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            limit: isSet(object.limit) ? bytesFromBase64(object.limit) : new Uint8Array(),
            window: isSet(object.window) ? duration_1.Duration.fromJSON(object.window) : undefined,
            incoming: isSet(object.incoming) ? bytesFromBase64(object.incoming) : new Uint8Array(),
            outgoing: isSet(object.outgoing) ? bytesFromBase64(object.outgoing) : new Uint8Array(),
            timeLeft: isSet(object.timeLeft) ? duration_1.Duration.fromJSON(object.timeLeft) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.limit !== undefined &&
            (obj.limit = base64FromBytes(message.limit !== undefined ? message.limit : new Uint8Array()));
        message.window !== undefined && (obj.window = message.window ? duration_1.Duration.toJSON(message.window) : undefined);
        message.incoming !== undefined &&
            (obj.incoming = base64FromBytes(message.incoming !== undefined ? message.incoming : new Uint8Array()));
        message.outgoing !== undefined &&
            (obj.outgoing = base64FromBytes(message.outgoing !== undefined ? message.outgoing : new Uint8Array()));
        message.timeLeft !== undefined && (obj.timeLeft = message.timeLeft ? duration_1.Duration.toJSON(message.timeLeft) : undefined);
        return obj;
    },
    create(base) {
        return exports.TransferRateLimit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTransferRateLimit();
        message.limit = object.limit ?? new Uint8Array();
        message.window = (object.window !== undefined && object.window !== null)
            ? duration_1.Duration.fromPartial(object.window)
            : undefined;
        message.incoming = object.incoming ?? new Uint8Array();
        message.outgoing = object.outgoing ?? new Uint8Array();
        message.timeLeft = (object.timeLeft !== undefined && object.timeLeft !== null)
            ? duration_1.Duration.fromPartial(object.timeLeft)
            : undefined;
        return message;
    },
};
function createBaseMessageRequest() {
    return { id: "" };
}
exports.MessageRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? String(object.id) : "" };
    },
    toJSON(message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        return obj;
    },
    create(base) {
        return exports.MessageRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMessageRequest();
        message.id = object.id ?? "";
        return message;
    },
};
function createBaseMessageResponse() {
    return { message: undefined };
}
exports.MessageResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== undefined) {
            types_1.GeneralMessage.encode(message.message, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = types_1.GeneralMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return { message: isSet(object.message) ? types_1.GeneralMessage.fromJSON(object.message) : undefined };
    },
    toJSON(message) {
        const obj = {};
        message.message !== undefined &&
            (obj.message = message.message ? types_1.GeneralMessage.toJSON(message.message) : undefined);
        return obj;
    },
    create(base) {
        return exports.MessageResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMessageResponse();
        message.message = (object.message !== undefined && object.message !== null)
            ? types_1.GeneralMessage.fromPartial(object.message)
            : undefined;
        return message;
    },
};
var tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis.Buffer) {
        return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis.btoa(bin.join(""));
    }
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
